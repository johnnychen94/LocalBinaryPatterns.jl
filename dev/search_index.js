var documenterSearchIndex = {"docs":
[{"location":"reference/#API-References","page":"API References","title":"API References","text":"","category":"section"},{"location":"reference/","page":"API References","title":"API References","text":"local_binary_pattern","category":"page"},{"location":"reference/#LocalBinaryPatterns.local_binary_pattern","page":"API References","title":"LocalBinaryPatterns.local_binary_pattern","text":"local_binary_pattern([f], X; [rotation], [uniform_degree])\n\nCompute the local binary pattern of gray image X.\n\nArguments\n\nf: function f(X, I, offsets) computes the block mode value. In the original version [1] it directly uses the center pixel value, i.e., f(X, I, offsets) = X[I]. See also average_mode.\nX::AbstractMatrix: the input image matrix. For colorful images, one can manually convert it to some monochrome space, e.g., Gray, the L-channel of Lab. One could also do channelwise LBP and then concatenate together.\n\nParameters\n\nThe parameters control whether and what degree additional encoding passses are used to compute more patterns that are more robust/invariant to certain changes, e.g., rotation. The following lists are ordered as encoding order. For example, if rotation=true and uniform_degree=2, then rotation encoding will be applied first.\n\nrotation=false: set true to generate patterns that are invariant to rotation [3]. For example, pattern 0b00001101 is equivalent to 0b01000011 when rotation=true.\nuniform_degree: the threshold number of pattern uniform degree. From [2] a typical choice is 2.If it is nothing(default value) then no uniform encoding is applied.\n\nExamples\n\njulia> X = [6 7 9; 5 6 3; 2 1 7]\n3×3 Matrix{Int64}:\n 6  7  9\n 5  6  3\n 2  1  7\n\njulia> local_binary_pattern(X)\n3×3 Matrix{UInt8}:\n 0xc0  0x40  0x00\n 0x68  0xa9  0x1b\n 0x28  0x6b  0x00\n\njulia> local_binary_pattern(X; rotation=true)\n3×3 Matrix{UInt8}:\n 0x03  0x01  0x00\n 0x0d  0x35  0x1b\n 0x05  0x5b  0x00\n\njulia> local_binary_pattern(X; uniform_degree=2)\n3×3 Matrix{UInt8}:\n 0xc0  0x40  0x00\n 0x09  0x09  0x09\n 0x09  0x09  0x00\n\nExtended help\n\nLocal binary pattern\n\nThe following is how local binary pattern is calculated, the original version[1]:\n\n3x3 block     center-thresholded     weights         multiplied by weights      sum\n6  7  9         1  1  1              1  8  32          1   8  32\n5  6  3  ==>    0  x  0     ==>      2  x  64  ==>     0   x  0            ==>  169\n2  1  7         1  0  1              4  16 128         0   0  128\n\nAny binary pattern of length 8, i.e., the center-thresholded result, can be uniquely represented as an UInt8 value; the weighted sum is the encoding process.\n\nRotation-invariant encoding\n\nThe rotation-invariant encoding is to map all elements in the bitrotation equivalent class to the minimal value of this class. For example, 0b11010000 and 0b01000011 belongs to the same class because bitrotate(0b01000011, -2) == 0b11010000, thus both values are mapped to 0b00001101. See also Eq.(8) in [2].\n\nFor 3x3 neighborhood matrix, applying rotation-invariant encoding decreases the possible number of binary patterns from 256 to 36.\n\nThe interpolation-based version provides more robust result for rotation-invariant pattern, see [2,4] for more details.\n\nUniform encoding\n\nAuthors of [2] states that certain local binary patterns are fundamental properties of texture, providing the vast majority, sometimes over 90 percent, of all 3x3 patterns. Those patterns are called \"uniform\" as they contain very few spatial transitions. Uniform degree is an additional encoding pass that controls at what circumstances can we set the block to miscellaneous class.\n\nFor example, in 8-bit mode, if uniform_degree=2, then 0b00001101 will be encoded as 9 (type miscellaneous) because it has 3 bit transitions, and 0b00001100 will be unchanged because it only has 2 bit transitions.\n\nReferences\n\n[1] T. Ojala, M. Pietikäinen, and D. Harwood, “A comparative study of texture measures with classification based on featured distributions,” Pattern Recognition, vol. 29, no. 1, pp. 51–59, Jan. 1996, doi: 10.1016/0031-3203(95)00067-4.\n[2] T. Ojala, M. Pietikäinen, and T. Mäenpää, “A Generalized Local Binary Pattern Operator for Multiresolution Gray Scale and Rotation Invariant Texture Classification,” in Advances in Pattern Recognition — ICAPR 2001, vol. 2013, S. Singh, N. Murshed, and W. Kropatsch, Eds. Berlin, Heidelberg: Springer Berlin Heidelberg, 2001, pp. 399–408. doi: 10.1007/3-540-44732-6_41.\n[3] Pietikäinen, Matti, Timo Ojala, and Zelin Xu. \"Rotation-invariant texture classification using feature distributions.\" Pattern recognition 33.1 (2000): 43-52.\n[4] T. Ojala, M. Pietikainen, and T. Maenpaa, “Multiresolution gray-scale and rotation invariant texture classification with local binary patterns,” IEEE Trans. Pattern Anal. Machine Intell., vol. 24, no. 7, pp. 971–987, Jul. 2002, doi: 10.1109/TPAMI.2002.1017623.\n\n\n\n\n\nlocal_binary_pattern([f], X, npoints, radius, interpolation=Linear(); [rotation], [uniform_degree])\n\nCompute the local binary pattern of gray image X using the interpolation-based original method with circular neighborhood matrix.\n\nThis produces better result for rotation=true case but is usually slower than the plain 3x3 matrix version local_binary_pattern(X).\n\nArguments\n\nnpoints::Int(4 ≤ npoints ≤ 32): the number of (uniform-spaced) neighborhood points.\nradius::Real(radius ≥ 1.0): the radius of the circular. Larger radius computes the   pattern of a larger local window/block.\ninterpolation::Union{Degree, InterpolationType}=Linear(): the interpolation method used   to generate non-grid pixel value. In most cases, Linear() are good enough. One can   also try other costly interpolation methods, e.g., Cubic(Line(OnGrid()))(also known as   \"bicubic\"), Lanczos(). See also Interpolations.jl for more choices.\n\ninfo: parameter choices\nThe following parameters are used in [1], with interpolation=Linear().npoints radius\n4 10\n8 10\n12 15\n16 20\n24 30\n\nnote: neighborhood order differences\nDifferent implementation might use different neighborhood orders; this will change the encoding result but will not change the overall distribution. For instance, local_binary_pattern(X) differs from local_binary_pattern(X, 8, 1, Constant()) only by how offsets (see below) are ordered; the former uses column-major top-left to bottom-right 3x3 matrix order and the latter uses circular order.\n\nExamples\n\njulia> X = [6 7 9; 5 6 3; 2 1 7]\n3×3 Matrix{Int64}:\n 6  7  9\n 5  6  3\n 2  1  7\n\njulia> local_binary_pattern(X, 4, 1) # 4-neighbor with circular radius 1\n3×3 Matrix{UInt32}:\n 0x00000001  0x00000001  0x00000000\n 0x00000003  0x00000002  0x0000000e\n 0x00000002  0x00000007  0x00000000\n\njulia> local_binary_pattern(X, 4, 1; rotation=true)\n3×3 Matrix{UInt32}:\n 0x00000001  0x00000001  0x00000000\n 0x00000003  0x00000001  0x00000007\n 0x00000001  0x00000007  0x00000000\n\nReferences\n\n[1] T. Ojala, M. Pietikainen, and T. Maenpaa, “Multiresolution gray-scale and rotation invariant texture classification with local binary patterns,” IEEE Trans. Pattern Anal. Machine Intell., vol. 24, no. 7, pp. 971–987, Jul. 2002, doi: 10.1109/TPAMI.2002.1017623.\n\n\n\n\n\nlocal_binary_pattern([f], X, block_size; [rotation], [uniform_degree])\n\nCompute the local binary pattern of gray image X of image blocks with size block_size. This method is usually called MB-LBP[1] or Locally Assembled Binary (LAB) feature[2] in the literature.\n\nArguments\n\nX::AbstractMatrix: the input image matrix. For colorful images, one can manually convert it to some monochrome space, e.g., Gray, the L-channel of Lab. One could also do channelwise LBP and then concatenate together.\nblock_size::Tuple{Int,Int}: positive integers that used to specify the size of each block. When block_size == (1, 1), this method degenerates to the pixel-version local_binary_pattern.\n\nFor the meaning and values of parameters rotation and uniform_degree please see the docs of local_binary_pattern.\n\nExamples\n\njulia> X = zeros(Int, 9, 9); X[1:3, 1:3] .= 50; X[4:6, 4:6] .= 1; X[7:9, 7:9] .= 50; X\n9×9 Matrix{Int64}:\n 50  50  50  0  0  0   0   0   0\n 50  50  50  0  0  0   0   0   0\n 50  50  50  0  0  0   0   0   0\n  0   0   0  1  1  1   0   0   0\n  0   0   0  1  1  1   0   0   0\n  0   0   0  1  1  1   0   0   0\n  0   0   0  0  0  0  50  50  50\n  0   0   0  0  0  0  50  50  50\n  0   0   0  0  0  0  50  50  50\n\njulia> local_binary_pattern(X, (3, 3))[4, 4] # 0b1000_0001\n0x81\n\njulia> local_binary_pattern(X, (3, 3); rotation=true)[4, 4] # 0b0000_0011\n0x03\n\njulia> local_binary_pattern(X, (3, 3); uniform_degree=2)[4, 4] # 0x09 (i.e., miscellaneous pattern)\n0x09\n\nExtended help\n\nThe following is how the block-version of local binary pattern computed with block_size=(3, 3). Check out local_binary_pattern for more details of the original pixel-version of local binary pattern.\n\n2  3  2  |  7  6  6  |  2  1  3\n1  2  3  |  5  3  4  |  7  7  3\n6  5  4  |  1  4  5  |  1  5  8\n-------------------------------     sum                compare          weighted          sum\n1  2  3  |  1  7  3  |  8  3  7            28  41  37           0  1  0           0 8 0\n1  2  1  |  4  3  6  |  5  2  2     ==>    20  38  45    ==>    0  x  1     ==>   0 x 64  ==> 200\n1  2  7  |  5  3  6  |  4  7  7            33  31  39           0  0  1           0 0 128\n-------------------------------\n4  2  4  |  8  1  5  |  3  7  7\n5  7  4  |  1  1  1  |  3  4  3\n3  3  1  |  5  1  8  |  1  8  3\n\nReferences\n\n[1] Zhang, Lun, et al. \"Face detection based on multi-block lbp representation.\" International conference on biometrics. Springer, Berlin, Heidelberg, 2007.\n[2] Yan, Shengye, et al. \"Locally assembled binary (LAB) feature with feature-centric cascade for fast and accurate face detection.\" 2008 IEEE Conference on Computer Vision and Pattern Recognition. IEEE, 2008.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Helpers","page":"API References","title":"Helpers","text":"","category":"section"},{"location":"reference/","page":"API References","title":"API References","text":"LocalBinaryPatterns.average_mode","category":"page"},{"location":"reference/#LocalBinaryPatterns.average_mode","page":"API References","title":"LocalBinaryPatterns.average_mode","text":"average_mode(X, I, offsets) -> value\nlocal_binary_pattern(average_mode, X, args...; kwargs...)\n\nCompute the local binary pattern using the average mode of the block.\n\nOriginal local binary pattern compares the neighbors with the center value X[I], this modified version instead uses the mean value of the block.\n\njulia> X = [6 7 9; 5 6 3; 2 1 7]\n3×3 Matrix{Int64}:\n 6  7  9\n 5  6  3\n 2  1  7\n\njulia> local_binary_pattern(average_mode, X)\n3×3 Matrix{UInt8}:\n 0xc0  0x40  0x00\n 0x68  0xa9  0x1b\n 0x28  0x69  0x01\n\nSee also local_binary_pattern for additional arguments and parameters.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Internal-utilities","page":"API References","title":"Internal utilities","text":"","category":"section"},{"location":"reference/","page":"API References","title":"API References","text":"LocalBinaryPatterns.rotation_encoding_table\nLocalBinaryPatterns.RotationEncodingTable\nLocalBinaryPatterns.uniform_encoding_table","category":"page"},{"location":"reference/#LocalBinaryPatterns.rotation_encoding_table","page":"API References","title":"LocalBinaryPatterns.rotation_encoding_table","text":"rotation_encoding_table(T, nbits)\nrotation_encoding_table(T, X::AbstractUnitRange)\n\nBuild the rotation-invariant encoding table. If global runtime cache exists, then reuse it.\n\n\n\n\n\n","category":"function"},{"location":"reference/#LocalBinaryPatterns.RotationEncodingTable","page":"API References","title":"LocalBinaryPatterns.RotationEncodingTable","text":"RotationEncodingTable{T<:Unsigned}(X)\n\nThe lookup table for the quotient space constructed using bitrotate equivalance relation on bit representation of datatype T.\n\nBy definition, a is equivalant to b(a  b) if there exists n such that bitrotate(a, n) == b.\n\nThis equivalance class gives a unique encoding map from xX to a, where a is the minimal value of the equivalance class x. For instance, the equivalance class of 0b10101001 (UInt8) is\n\n0b10101001 # 169\n0b01010011 # 83\n0b10100110 # 166\n0b01001101 # 77\n0b10011010 # 154\n0b00110101 # 53\n0b01101010 # 106\n0b11010100 # 212\n\nthus f(169) == 0x35 == 53.\n\njulia> using LocalBinaryPatterns: RotationEncodingTable\n\njulia> X = RotationEncodingTable{UInt8}(0:255);\n\njulia> X[169] # 53\n0x35\n\njulia> X = RotationEncodingTable{UInt8}(128:255);\n\njulia> X[169] # 154\n0x9a\n\nThe values in the lookup table is implemented in lazy cache manner so the real computation only happens once at the first retrieval.\n\nThis lookup table is used to build an efficient implementation of rotation-invariant local binary pattern [1].\n\nReferences\n\n[1] T. Ojala, M. Pietikäinen, and T. Mäenpää, “A Generalized Local Binary Pattern Operator for Multiresolution Gray Scale and Rotation Invariant Texture Classification,” in Advances in Pattern Recognition — ICAPR 2001, vol. 2013, S. Singh, N. Murshed, and W. Kropatsch, Eds. Berlin, Heidelberg: Springer Berlin Heidelberg, 2001, pp. 399–408. doi: 10.1007/3-540-44732-6_41.\n\n\n\n\n\n","category":"type"},{"location":"reference/#LocalBinaryPatterns.uniform_encoding_table","page":"API References","title":"LocalBinaryPatterns.uniform_encoding_table","text":"uniform_encoding_table(T, X::AbstractUnitRange, degree::Int)\n\nGet the encoding table of X using uniform degree filter.\n\nA uniform degree filter is defined as f(x) = U(x) > degree ? P+1 : x, where P is number of bits of x, and U(x) is the circular bit transition of x with bit representation of datatype T.\n\nFor example, 0b0000001 has 2 bit transitions thus is unchanged, while 0b00000101 has 4 bit transitions. The transition is count in circular sense, i.e., the highest and lowest bits are also compared.\n\njulia> using LocalBinaryPatterns: uniform_encoding_table\n\njulia> X = uniform_encoding_table(UInt8, 0:255, 2);\n\njulia> X[0b0000001]\n0x01\n\njulia> X[0b0000101] # miscellaneous\n0x09\n\nThis function is used to distinguish local binary patterns from texture patterns and miscellaneous patterns. See [1] for more information.\n\ninfo: Runtime caches\nFor better performance, this function uses a runtime cache to store the lookup and shared among all callers. The result is expected to be used in read-only mode.\n\nReferences\n\n[1] T. Ojala, M. Pietikäinen, and T. Mäenpää, “A Generalized Local Binary Pattern Operator for Multiresolution Gray Scale and Rotation Invariant Texture Classification,” in Advances in Pattern Recognition — ICAPR 2001, vol. 2013, S. Singh, N. Murshed, and W. Kropatsch, Eds. Berlin, Heidelberg: Springer Berlin Heidelberg, 2001, pp. 399–408. doi: 10.1007/3-540-44732-6_41.\n\n\n\n\n\n","category":"function"},{"location":"#LocalBinaryPatterns","page":"Home","title":"LocalBinaryPatterns","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for LocalBinaryPatterns.","category":"page"}]
}
